{"conceptual":"\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"3\" sourceendlinenumber=\"3\">Beginning with version <strong>3.2.0</strong> a new subscription model is available in Event Store. This model is known as &quot;competing consumers&quot; and is similar to subscriptions models you may have used in the past such as AMQP. This document serves as a high level overview of the functionality, what it can provide, and when you may want to use it.</p>\n<h2 id=\"what-is-competing-consumers\" sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"5\" sourceendlinenumber=\"5\">What is Competing Consumers</h2>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"7\" sourceendlinenumber=\"7\">Competing Consumers differs in usage and functionality from the <code>Subscribe</code> operation or from a <code>CatchUpSubscription</code>. <!-- TODO: We han't mentioned this yet, is this subscribe? --> For example <code>SubscribeToStream</code> will read the events from this point forward that happen in a stream. A <code>CatchUpSubscription</code> will read all the events in a stream to your client from a given point.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"9\" sourceendlinenumber=\"9\">Both a <code>Subscription</code> and a <code>CatchupSubscription</code> use a model where the client holds the state of the subscription, much like a blog client remembers the last post you read. The server does not hold any state particular to a given client. With Competing Consumers the server remembers the state of the subscription, allowing for different modes of operations compared to a subscription where the client holds the subscription state. <!-- TODO: Is this repetetive? --></p>\n<h2 id=\"subscription-groups\" sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"11\" sourceendlinenumber=\"11\">Subscription Groups</h2>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"13\" sourceendlinenumber=\"13\">The first step in using Competing Consumers is to create a new subscription. You can do this with the HTTP API or with the client API <code>CreatePersistentSubscription</code>. This creates the server-side subscription group that you use in the future. There are lots of options you can pass to a subscription group including <code>ReadBatchSizes</code>, <code>MaxRetryCounts</code>, and how often to <code>CheckPoint</code> the subscription <!-- TODO: Should the others also have brief explanations -->.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">You create a subscription as part of a deployment or an administrative task. You can create subscription groups to map to any stream.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"17\" sourceendlinenumber=\"17\">For example to create a consumer group <code>foo</code> on the stream <code>bar</code>.</p>\n<!-- TODO: What specificslly is this an example of? -->\n<pre sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"21\" sourceendlinenumber=\"23\"><code class=\"lang-http\">/subscriptions/bar/foo\n</code></pre><p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"25\" sourceendlinenumber=\"25\">You can also create multiple subscription groups on a single stream.</p>\n<pre sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"27\" sourceendlinenumber=\"30\"><code class=\"lang-http\">/subscriptions/bar/foo\n/subscriptions/bar/baz\n</code></pre><p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"32\" sourceendlinenumber=\"32\">One major difference with client-based subscriptions is that a subscription group can have &#39;N&#39; clients connected to it. The subscription group as a whole represents the subscription. If you connect three clients to a subscription group, only one of the clients will normally receive the message, not all three as it would work with three <code>CatchUpSusbcription</code>s.</p>\n<!-- TODO: Is this necessary? -->\n<div class=\"NOTE\" sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"36\" sourceendlinenumber=\"36\"><h5>Note</h5><p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">It will be discussed later in this document but in the case of retries, connection failures, or server failures, more than one subscriber in a subscriber group can see a given message. Therefore this model is known as At-Least-Once messaging. Clients must be able to handle receiving a message more than one time.</p>\n</div>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"39\" sourceendlinenumber=\"39\">The next step is to connect a client to the subscription group. In the .NET client api there is a <code>ConnectToPersistentSubscription</code> method  which takes the stream or group that you want to connect to. It also takes a parameter which is the maximum number of in flight messages. This parameter is key to understanding how the subscription group works.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"41\" sourceendlinenumber=\"41\">When a message is dispatched to a client of the subscription group it is considered &quot;in process&quot; until it is acknowledged by the client, not acknowledged by the client, or timed out. The in flight messages limit refers to how many messages can be &quot;in process&quot; at a given point in time by a client, each client sets their limit at their time of connection. Once you have reached this limit the server will not push another message to your client until a slot becomes available due to an &quot;in process&quot; message marked no longer in process.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"43\" sourceendlinenumber=\"43\">If you had 7 messages in a subscription and two clients (A/B) (A is allowed 2, and B is allowed 3) the subscription would push messages 1 and 2 to client A and 3,4 and 5 to client B. Message 6 would not be able to be processed until one of the messages 1,2,3,4 and 5 were moved from the &quot;in process&quot; by an ack, nak, or timeout from clients A or B.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"45\" sourceendlinenumber=\"45\">The most common mechanism for a slot becoming open would be that client A(or B) returns an acknowledgement that they have processed, say message 1. They can also return a not acknowledgement of a message with hints to the server as to what to do with the message (skip/retry/park/server decides). A timeout of the message (which is configurable) is another way this can happen.</p>\n<div class=\"NOTE\" sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"47\" sourceendlinenumber=\"47\"><h5>Note</h5><p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"48\" sourceendlinenumber=\"48\">Tuning of the maximum number of inflight messages and message timeouts are important when looking at overall subscription performance.</p>\n</div>\n<h2 id=\"parked-messages\" sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"50\" sourceendlinenumber=\"50\">Parked Messages</h2>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"52\" sourceendlinenumber=\"52\">One option that can return a &quot;not acknowledged&quot; is that the message is not be able to be processed on retries and should be parked (this is also known as a dead letter queue). Messages can also be parked due to them being retried more than a certain number of times.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"54\" sourceendlinenumber=\"54\">For every subscription group there is another stream known as the &quot;parked message queue&quot;. You can replay the parked message queue at any point to the subscription group either via the UI or via the restful interface for competing consumers. For more information please see version specific information<!-- how can this be more useful -->. It is important in a production environment to monitor the count of parked messages as these represent messages that were <strong>not</strong> delivered to the subscriber group as there were failures.</p>\n<h2 id=\"checkpoints\" sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"56\" sourceendlinenumber=\"56\">Checkpoints</h2>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"58\" sourceendlinenumber=\"58\">As the subscription is processed, it will occasionally write in a persistent way the place it knows that it has processed all messages prior. This is helpful in the case of a server restart or a crash so the subscription group can continue from this point as opposed to starting from the beginning of the subscription. If running in a clustered version the subscription groups will move to another server. In the case of a crash they will be restarted from their last checkpoint. A reload to a checkpoint can cause a subscription to duplicate messages that are ahead of the latest checkpoint but have been acknowledged.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"60\" sourceendlinenumber=\"60\">The configuration settings on the subscription group control how the server checkpoints. You can control how often checkpoints are written via three main config points <code>CheckpointInterval</code>, <code>MinToCheckpoint</code>, and <code>MaxToCheckpoint</code>. An interval, of say 3 seconds will write a checkpoint on the interval providing the number of messages to checkpoint is greater than <code>MinToCheckpoint</code>. When <code>MaxToCheckpoint</code> is reached a checkpoint will always be written.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"62\" sourceendlinenumber=\"62\">If you have an interval of one second, <code>MinToCheckpoint</code> at 5 and <code>MaxToCheckpoint</code> at 10 (these numbers are normally larger for busy subscriptions)</p>\n<pre sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"64\" sourceendlinenumber=\"72\"><code class=\"lang-text\">interval hit: messages = 3 //no checkpoint written\non ack: messages = 4 //no checkpoint written\ninterval hit: messages = 4 //no checkpoint written\non ack: messages = 5 //no checkpoint written\non interval hit: messages = 5 //checkpoint written\nor\non ack messages=10 //checkpoint written\n</code></pre><p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"74\" sourceendlinenumber=\"74\">Understanding how checkpointing works and paying careful attention to the behavior of your stream can help reduce server workload and help prevent receiving too many repeated messages in the case of a server failover. On a stream receiving few messages the above settings are fine. On a stream receiving a few hundred or thousand messages per second these values need to be significantly higher. A general rule of thumb is the maximum should be 1-5 seconds of message throughput.</p>\n<div class=\"NOTE\" sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"76\" sourceendlinenumber=\"76\"><h5>Note</h5><p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"77\" sourceendlinenumber=\"77\">The checkpoints themselves are stored in streams and are often recycled quickly. For this reason it is generally recommended that you occasionally run a scavenge process on your servers if using competing consumers.</p>\n</div>\n<h2 id=\"when-to-use-competing-consumers\" sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"79\" sourceendlinenumber=\"79\">When to Use Competing Consumers</h2>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"81\" sourceendlinenumber=\"81\">As mentioned throughout this guide, there are many pros and cons when comparing client-based vs server-based subscription models. The table below summarizes some of these trade offs.</p>\n<table>\n    <thead>\n        <tr>\n            <th>Feature</th>\n            <th>Client Based</th>\n            <th>Server Based</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>Many clients connected</td>\n            <td>Yes</td>\n            <td>Yes</td>\n        </tr>\n        <tr>\n            <td>Clients receive all messages</td>\n            <td>Yes</td>\n            <td>No</td>\n        </tr>\n        <tr>\n            <td>Monitorable</td>\n            <td>No<em></em></td>\n            <td>Yes</td>\n        </tr><br>        <tr>\n            <td>Assured Ordering</td>\n            <td>Yes</td>\n            <td>No</td>\n        </tr>\n        <tr>\n            <td>Requires Configuration</td>\n            <td>No</td>\n            <td>Yes</td>\n        </tr><br>        <tr>\n            <td>Load balancing</td>\n            <td>No</td>\n            <td>Yes</td>\n        </tr>\n        <tr>\n            <td>HA clients</td>\n            <td>No*</td>\n            <td>Yes</td>\n        </tr>\n    </tbody>\n</table>\n\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"130\" sourceendlinenumber=\"130\">Competing consumers will allow you to connect one or many clients to a given subscription group. This can allow for things like load balancing the work across them or making the clients themselves highly available easily. If you lose a client the workload will just be spread over the other connected clients. With a <code>CatchupSubscription</code> it is difficult to make a highly available subscriber (it duplicates everything) load balancing is also difficult, as with a <code>CatchUpSubscription</code> each client will receive every message.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"132\" sourceendlinenumber=\"132\">For something like a projection of an event stream into a read model, a client will generally prefer to use a <code>CatchUpSubscription</code> as opposed to a competing consumer group. This is because when performing this process, receiving the events in order is important. Any time that ordering becomes a primary concern, a <code>CatchUpSubscription</code> is probably the best bet.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"134\" sourceendlinenumber=\"134\">Another tradeoff to consider is that since a server-based subscription stores the state of the subscription on the server you can centrally monitor the subscriptions from a single point. If they are client-based subscriptions you can do this as well providing all your client subscriptions store their state in a particular place but it is left to the user to implement.</p>\n<h2 id=\"monitoring\" sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"136\" sourceendlinenumber=\"136\">Monitoring</h2>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"138\" sourceendlinenumber=\"138\">You can monitor all subscriber state within Event Store. You can do this through the UI (<em>subscriptions</em> tab) or via the restful API (<em><a href=\"http://yourserver/subscriptions\" data-raw-source=\"&lt;http://yourserver/subscriptions&gt;\" sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"138\" sourceendlinenumber=\"138\">http://yourserver/subscriptions</a></em>). You can monitor all competing consumer subscriptions here, and there are dashboards to see what is going on.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"140\" sourceendlinenumber=\"140\">Generally it is most important to monitor the relationship between the <code>lastProcessedMessage</code>, the <code>lastKnownMessage</code>, and the throughput of the subscription. This tells you the last processed message was &#39;x&#39;, the last known message is &#39;y&#39; and your current throughput is &#39;t&#39;. <code>X - Y / t</code> gives you a rough estimate of how far behind the subscription group is from live.</p>\n<p sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"142\" sourceendlinenumber=\"142\">You can also measure your clients, timing each message passed to a client. Using the <code>extrastatistics</code> configuration option, the subscription will track a histogram of the timings of the client(s). From this histogram you can get statistics such as average, standard deviation, quintiles, and %s (90,95,99,99.9,etc) about how your client is behaving in terms of timings.</p>\n","type":"Conceptual","source":{"remote":{"path":"introduction/competing-consumers.md","branch":"swagger-docfx","repo":"git@github.com:EventStore/docs.geteventstore.com.git"},"startLine":0,"endLine":0,"isExternal":false},"path":"introduction/competing-consumers.md","documentation":{"remote":{"path":"introduction/competing-consumers.md","branch":"swagger-docfx","repo":"git@github.com:EventStore/docs.geteventstore.com.git"},"startLine":0,"endLine":0,"isExternal":false},"_docfxVersion":"2.31.0.0","_systemKeys":["conceptual","type","source","path","documentation","title","rawTitle","wordCount"],"title":"Competing Consumers Introduction","rawTitle":"<h1 id=\"competing-consumers-introduction\" sourcefile=\"introduction/competing-consumers.md\" sourcestartlinenumber=\"1\" sourceendlinenumber=\"1\">Competing Consumers Introduction</h1>","wordCount":1678,"_lang":"csharp","_tocPath":"docs/toc.html","_rel":"../../","_path":"docs/introduction/competing-consumers.html","_key":"introduction/competing-consumers.md","_tocRel":"../toc.html","_tocKey":"~/toc.md","__global":{"classesInSubtitle":"Classes","structsInSubtitle":"Structs","interfacesInSubtitle":"Interfaces","enumsInSubtitle":"Enums","delegatesInSubtitle":"Delegates","constructorsInSubtitle":"Constructors","fieldsInSubtitle":"Fields","propertiesInSubtitle":"Properties","methodsInSubtitle":"Methods","eventsInSubtitle":"Events","operatorsInSubtitle":"Operators","eiisInSubtitle":"Explicit Interface Implementations","functionsInSubtitle":"Functions","membersInSubtitle":"Members","improveThisDoc":"Improve this Doc","viewSource":"View Source","inheritance":"Inheritance","inheritedMembers":"Inherited Members","namespace":"Namespace","assembly":"Assembly","syntax":"Syntax","overrides":"Overrides","implements":"Implements","remarks":"Remarks","examples":"Examples","seealso":"See Also","declaration":"Declaration","parameters":"Parameters","typeParameters":"Type Parameters","type":"Type","name":"Name","description":"Description","returns":"Returns","fieldValue":"Field Value","propertyValue":"Property Value","eventType":"Event Type","exceptions":"Exceptions","condition":"Condition","extensionMethods":"Extension Methods","note":"<h5>Note</h5>","warning":"<h5>Warning</h5>","tip":"<h5>Tip</h5>","important":"<h5>Important</h5>","caution":"<h5>Caution</h5>","_shared":{}}}