{"conceptual":"<p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"7\" sourceendlinenumber=\"7\">This document walks through the .NET client API for setting up and consuming competing consumer subscription groups. For an overview on competing consumers and how they relate to other subscription types read <a href=\"~/introduction/competing-consumers.md\" data-raw-source=\"[the overview document](~/introduction/competing-consumers.md)\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"7\" sourceendlinenumber=\"7\">the overview document</a>.</p>\n<h1 id=\"methods\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"9\" sourceendlinenumber=\"9\">Methods</h1>\n<h2 id=\"creating-a-persistent-subscription\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"11\" sourceendlinenumber=\"11\">Creating a Persistent Subscription</h2>\n<!-- TODO: Explanation? -->\n<pre sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"17\"><code class=\"lang-csharp\">Task&lt;PersistentSubscriptionCreateResult&gt; CreatePersistentSubscriptionAsync(string stream, string groupName, PersistentSubscriptionSettings settings, UserCredentials credentials);\n</code></pre><h2 id=\"updating-a-persistent-subscription\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"19\" sourceendlinenumber=\"19\">Updating a Persistent Subscription</h2>\n<!-- TODO: Explanation? -->\n<pre sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"23\" sourceendlinenumber=\"25\"><code class=\"lang-csharp\">Task&lt;PersistentSubscriptionUpdateResult&gt; UpdatePersistentSubscriptionAsync(string stream, string groupName, PersistentSubscriptionSettings settings, UserCredentials credentials);\n</code></pre><h2 id=\"deleting-a-persistent-subscription\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"27\" sourceendlinenumber=\"27\">Deleting a Persistent Subscription</h2>\n<!-- TODO: Explanation? -->\n<pre sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"31\" sourceendlinenumber=\"33\"><code class=\"lang-csharp\">Task&lt;PersistentSubscriptionDeleteResult&gt; DeletePersistentSubscriptionAsync(string stream, string groupName, UserCredentials userCredentials = null);\n</code></pre><h2 id=\"connecting-to-a-persistent-subscription\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"35\" sourceendlinenumber=\"35\">Connecting to a Persistent Subscription</h2>\n<!-- TODO: Explanation? -->\n<pre sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"39\" sourceendlinenumber=\"48\"><code class=\"lang-csharp\">EventStorePersistentSubscription ConnectToPersistentSubscription(\n    string groupName,\n    string stream,\n    Func&lt;EventStorePersistentSubscription, ResolvedEvent, Task&gt; eventAppeared,\n    Action&lt;EventStorePersistentSubscription, SubscriptionDropReason, Exception&gt; subscriptionDropped = null,\n    UserCredentials userCredentials = null,\n    int bufferSize = 10,\n    bool autoAck = true);\n</code></pre><h2 id=\"persistent-subscription-settings\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"50\" sourceendlinenumber=\"50\">Persistent Subscription Settings</h2>\n<p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"52\" sourceendlinenumber=\"52\">Both the <code>Create</code> and <code>Update</code> methods take a <code>PersistentSubscriptionSettings</code> object as a parameter. The methods use this obje to provide the settings for the persistent subscription. There is also a fluent builder for these options that you can locate using the <code>Create()</code> method. The following table shows the options you can set on a persistent subscription.</p>\n<table>\n    <thead>\n        <tr>\n            <th>Member</th>\n            <th>Description</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><code>ResolveLinkTos</code></td>\n            <td>Tells the subscription to resolve link events.</td>\n        </tr>\n        <tr>\n            <td><code>DoNotResolveLinkTos</code></td>\n            <td>Tells the subscription to not resolve link events.</td>\n        </tr>\n        <tr>\n            <td><code>PreferRoundRobin</code></td>\n            <td>If possible preference a round robin between the connections with messages (if not possible will use next available).</td>\n        </tr>\n        <tr>\n            <td><code>PreferDispatchToSingle</code></td>\n            <td>If possible preference dispatching to a single connection (if not possible will use next available).</td>\n        </tr>\n        <tr>\n            <td><code>StartFromBeginning</code></td>\n            <td>Start the subscription from the first event in the stream.</td>\n        </tr>\n        <tr>\n            <td><code>StartFrom(int position)</code></td>\n            <td>Start the subscription from the position-th event in the stream.</td>\n        </tr>\n        <tr>\n            <td><code>StartFromCurrent</code></td>\n            <td>Start the subscription from the current position.</td>\n        </tr>\n        <tr>\n            <td><code>WithMessageTimeoutOf(TimeSpan timeout)</code></td>\n            <td>Sets the timeout for a client before retrying the message.</td>\n        </tr>\n        <tr>\n            <td><code>CheckPointAfter(TimeSpan time)</code></td>\n            <td>The amount of time the system should try to checkpoint after.</td>\n        </tr>\n        <tr>\n            <td><code>MinimumCheckPointCountOf(int count)</code></td>\n            <td>The minimum number of messages to write a checkpoint for.</td>\n        </tr>\n       <tr>\n            <td><code>MaximumCheckPointCountOf(int count)</code></td>\n            <td>The maximum number of messages not checkpointed before forcing a checkpoint.</td>\n        </tr>\n        <tr>\n            <td><code>WithMaxRetriesOf(int count)</code></td>\n            <td>Sets the number of times to retry a message should before considering it a bad message.</td>\n        </tr>\n        <tr>\n            <td><code>WithLiveBufferSizeOf(int count)</code></td>\n            <td>The size of the live buffer (in memory) before resorting to paging.</td>\n        </tr>\n        <tr>\n            <td><code>WithReadBatchOf(int count)</code></td>\n            <td>The size of the read batch when in paging mode.</td>\n        </tr>\n        <tr>\n            <td><code>WithBufferSizeOf(int count)</code></td>\n            <td>The number of messages to buffer when in paging mode.</td>\n        </tr>\n        <tr>\n            <td><code>WithExtraStatistics</code></td>\n            <td>Tells the backend to measure timings on the clients so statistics will contain histograms of them.</td>\n        </tr><br>    </tbody>\n</table>\n\n<h2 id=\"creating-a-subscription-group\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"129\" sourceendlinenumber=\"129\">Creating a Subscription Group</h2>\n<p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"131\" sourceendlinenumber=\"131\">The first step of dealing with a subscription group is to create one. You will receive an error if you attempt to create a subscription group multiple times. You must have admin permissions to create a persistent subscription group.</p>\n<div class=\"NOTE\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"133\" sourceendlinenumber=\"133\"><h5>Note</h5><p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"134\" sourceendlinenumber=\"134\">Normally you wouldn&#39;t create the subscription group in your general executable code. Instead you normally create it as a step during an install or as an admin task when setting up. You should assume the subscription exists in your code.</p>\n</div>\n<pre sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"136\" sourceendlinenumber=\"144\"><code class=\"lang-csharp\">PersistentSubscriptionSettings settings = PersistentSubscriptionSettings.Create()\n                                                                .DoNotResolveLinkTos()\n                                                                .StartFromCurrent();\n_result = _conn.CreatePersistentSubscriptionAsync(_stream,\n                                                  &quot;agroup&quot;,\n                                                  settings,\n                                                  MyCredentials).Result;                            \n</code></pre><table>\n    <thead>\n        <tr>\n            <th>Parameter</th>\n            <th>Description</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><code>string stream</code></td>\n            <td>The stream to the persistent subscription is on.</td>\n        </tr>\n        <tr>\n            <td><code>string groupName</code></td>\n            <td>The name of the subscription group to create.</td>\n        </tr>\n        <tr>\n            <td><code>PersistentSubscriptionSettings settings</code></td>\n            <td>The settings to use when creating this subscription.</td>\n        </tr>\n        <tr>\n            <td><code>UserCredentials credentials</code></td>\n            <td>The user credentials to use for this operation.</td>\n        </tr><br>    </tbody>\n</table>\n\n<h2 id=\"updating-a-subscription-group\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"173\" sourceendlinenumber=\"173\">Updating a Subscription Group</h2>\n<p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"175\" sourceendlinenumber=\"175\">You can also edit the settings of an existing subscription group while it is running, it is not needed to delete and recreate it to change settings. When you update the subscription group, however it will reset itself internally dropping the connections and having them reconnect. You must have admin permissions to update a persistent subscription group.</p>\n<pre sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"177\" sourceendlinenumber=\"185\"><code class=\"lang-csharp\">PersistentSubscriptionSettings settings = PersistentSubscriptionSettings.Create()\n                                                                .DoNotResolveLinkTos()\n                                                                .StartFromCurrent();\n_result = _conn.UpdatePersistentSubscriptionAsync(_stream,\n                                                  &quot;agroup&quot;,\n                                                  settings,\n                                                  MyCredentials).Result;                            \n</code></pre><div class=\"NOTE\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"187\" sourceendlinenumber=\"187\"><h5>Note</h5><p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"188\" sourceendlinenumber=\"188\">If you change settings such as start from beginning <!-- TODO: What settings? -->, this will not reset the groups checkpoint. If you want to change the current position in an update you must delete and recreate the subscription group.<span><p>\n</span></div>\n<table>\n    <thead>\n        <tr>\n            <th>Parameter</th>\n            <th>Description</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><code>string stream</code></td>\n            <td>The stream to the persistent subscription is on.</td>\n        </tr>\n        <tr>\n            <td><code>string groupName</code></td>\n            <td>The name of the subscription group to update.</td>\n        </tr>\n        <tr>\n            <td><code>PersistentSubscriptionSettings settings</code></td>\n            <td>The settings to use when updating this subscription.</td>\n        </tr>\n        <tr>\n            <td><code>UserCredentials credentials</code></td>\n            <td>The user credentials to use for this operation.</td>\n        </tr><br>    </tbody>\n</table>\n\n<h2 id=\"deleting-a-subscription-group\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"217\" sourceendlinenumber=\"217\">Deleting a Subscription Group</h2>\n<p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"219\" sourceendlinenumber=\"219\">At times you may wish to remove a subscription group. You do this with the delete operation. Much like the creation of groups, you rarely do this in your runtime code and is normally undertaken by an administrator running a script.</p>\n<pre sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"221\" sourceendlinenumber=\"225\"><code class=\"lang-csharp\">var result = _conn.DeletePersistentSubscriptionAsync(stream,\n                                                     &quot;groupname&quot;,\n                                                     DefaultData.AdminCredentials).Result;\n</code></pre><table>\n    <thead>\n        <tr>\n            <th>Parameter</th>\n            <th>Description</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><code>string stream</code></td>\n            <td>The stream to the persistent subscription is on.</td>\n        </tr>\n        <tr>\n            <td><code>string groupName</code></td>\n            <td>The name of the subscription group to update.</td>\n        </tr>\n        <tr>\n            <td><code>UserCredentials credentials</code></td>\n            <td>The user credentials to use for this operation.</td>\n        </tr><br>    </tbody>\n</table>\n\n<h2 id=\"connecting-to-a-subscription-group\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"250\" sourceendlinenumber=\"250\">Connecting to a Subscription Group</h2>\n<p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"252\" sourceendlinenumber=\"252\">Once you have created a subscription group N clients can connect to that subscription group. Generally a subscription in your application should only have the connect in your code, you should assume that the subscription has been created either via the client API, the restful API, or manually in the UI.</p>\n<p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"254\" sourceendlinenumber=\"254\">The most important parameter to pass when connecting is the buffer size. This represents how many outstanding messages the server should allow this client. If this number is too small your subscription will spend much of its time idle as it waits for an acknowledgement to come back from the client. If it&#39;s too big you will be wasting resources and can possibly start timing out messages depending on the speed of your processing.</p>\n<pre sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"256\" sourceendlinenumber=\"261\"><code class=\"lang-csharp\">var subscription = _conn.ConnectToPersistentSubscription(&quot;foo&quot;,\n                                                         &quot;nonexisting2&quot;,\n                                                         (sub, e) =&gt; Console.Write(&quot;appeared&quot;),\n                                                         (sub, reason, ex) =&gt;{});\n</code></pre><table>\n    <thead>\n        <tr>\n            <th>Parameter</th>\n            <th>Description</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><code>string stream</code></td>\n            <td>The stream to the persistent subscription is on.</td>\n        </tr>\n        <tr>\n            <td><code>string groupName</code></td>\n            <td>The name of the subscription group to connect to.</td>\n        </tr>\n        <tr>\n            <td><code>Action&lt;EventStorePersistentSubscription, ResolvedEvent&gt; eventAppeared</code></td>\n            <td>The action to call when an event arrives over the subscription.</td>\n        </tr>\n        <tr>\n            <td><code>Action&lt;EventStorePersistentSubscription, SubscriptionDropReason, Exception&gt; subscriptionDropped</code></td>\n            <td>The action to call if the subscription is dropped.</td>\n        </tr>\n        <tr>\n            <td><code>UserCredentials credentials</code></td>\n            <td>The user credentials to use for this operation.</td>\n        </tr>\n        <tr>\n            <td><code>int bufferSize</code></td>\n            <td>The number of in-flight messages this client is allowed.</td>\n        </tr>\n        <tr>\n            <td><code>bool autoAck</code></td>\n            <td>Whether to automatically acknowledge messages after eventAppeared returns.</td>\n        </tr><br>    </tbody>\n</table>\n\n<h2 id=\"acknowledgements\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"302\" sourceendlinenumber=\"302\">Acknowledgements</h2>\n<p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"304\" sourceendlinenumber=\"304\">Clients must acknowledge (or not acknowledge) messages in the competing consumer model. If you enable auto-ack the subscription will automatically acknowledge messages once your handler completes them. If you throw an exception it will shutdown your subscription with a message and the uncaught exception.</p>\n<p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"306\" sourceendlinenumber=\"306\">You can choose to not auto-ack messages. This can be useful when you have multi-threaded processing of messages in your subscriber and need to pass control to something else. There are methods on the subscription object that you can call <code>Acknowledge</code> and <code>NotAcknowledge</code> both take a <code>ResolvedEvent</code> (the one you processed) both also have overloads for passing and <code>IEnumerable&lt;ResolvedEvent&gt;</code>.</p>\n<h2 id=\"consumer-strategies\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"308\" sourceendlinenumber=\"308\">Consumer Strategies</h2>\n<p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"310\" sourceendlinenumber=\"311\">When creating a persistent subscription the settings allow for different consumer strategies via the <code>WithNamedConsumerStrategy</code> method. Built in strategies are defined in the enum <code>SystemConsumerStrategies</code>.</p>\n<div class=\"NOTE\" sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"313\" sourceendlinenumber=\"313\"><h5>Note</h5><p sourcefile=\"dotnet-api/competing-consumers.md\" sourcestartlinenumber=\"314\" sourceendlinenumber=\"314\">HTTP clients bypass the consumer strategy. This means any ordering or pinning will be ignored.<span><p>\n</span></div>\n<table>\n    <thead>\n        <tr>\n            <th>Strategy Name</th>\n            <th>Description</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>RoundRobin (default)</td>\n            <td>Distributes events to all clients evenly. If the client bufferSize is reached the client is ignored until events are acknowledged/not acknowledged.</td>\n        </tr>\n        <tr>\n            <td>DispatchToSingle</td>\n            <td>Distributes events to a single client until the bufferSize is reached. After which the next client is selected in a round robin style and the process is repeated.</td>\n        </tr>\n        <tr>\n            <td>Pinned</td>\n            <td>\n                For use with an indexing projection such as the system $by_category projection.\n                <p>\n                Each event is inspected for it&#39;s source stream id. This id is hashed to one of 1024 buckets which are assigned to individual clients. When a client disconnects it&#39;s buckets are assigned to other clients. When a client connects it is assigned some of the existing buckets. This naively attempts to maintain a balanced work load.\n                <p>\n                The main aim of this strategy is to decrease the likelihood of concurrency and ordering issues whilst maintaining load balancing. <em>This is not a guarantee</em> and the usual ordering and concurrency issues must be handled.\n            </td>\n        </tr><br>    </tbody>\n</table>\n","type":"Conceptual","source":{"remote":{"path":"dotnet-api/competing-consumers.md","branch":"swagger-docfx","repo":"git@github.com:EventStore/docs.geteventstore.com.git"},"startLine":0,"endLine":0,"isExternal":false},"path":"dotnet-api/competing-consumers.md","documentation":{"remote":{"path":"dotnet-api/competing-consumers.md","branch":"swagger-docfx","repo":"git@github.com:EventStore/docs.geteventstore.com.git"},"startLine":0,"endLine":0,"isExternal":false},"_docfxVersion":"2.31.0.0","_systemKeys":["conceptual","type","source","path","documentation","title","rawTitle","wordCount"],"title":"Competing Consumers","rawTitle":"","section":".NET API","version":"4.0.2","wordCount":1298,"_lang":"csharp","_tocPath":"docs/toc.html","_rel":"../../","_path":"docs/dotnet-api/competing-consumers.html","_key":"dotnet-api/competing-consumers.md","_tocRel":"../toc.html","_tocKey":"~/toc.md","__global":{"classesInSubtitle":"Classes","structsInSubtitle":"Structs","interfacesInSubtitle":"Interfaces","enumsInSubtitle":"Enums","delegatesInSubtitle":"Delegates","constructorsInSubtitle":"Constructors","fieldsInSubtitle":"Fields","propertiesInSubtitle":"Properties","methodsInSubtitle":"Methods","eventsInSubtitle":"Events","operatorsInSubtitle":"Operators","eiisInSubtitle":"Explicit Interface Implementations","functionsInSubtitle":"Functions","membersInSubtitle":"Members","improveThisDoc":"Improve this Doc","viewSource":"View Source","inheritance":"Inheritance","inheritedMembers":"Inherited Members","namespace":"Namespace","assembly":"Assembly","syntax":"Syntax","overrides":"Overrides","implements":"Implements","remarks":"Remarks","examples":"Examples","seealso":"See Also","declaration":"Declaration","parameters":"Parameters","typeParameters":"Type Parameters","type":"Type","name":"Name","description":"Description","returns":"Returns","fieldValue":"Field Value","propertyValue":"Property Value","eventType":"Event Type","exceptions":"Exceptions","condition":"Condition","extensionMethods":"Extension Methods","note":"<h5>Note</h5>","warning":"<h5>Warning</h5>","tip":"<h5>Tip</h5>","important":"<h5>Important</h5>","caution":"<h5>Caution</h5>","_shared":{}}}